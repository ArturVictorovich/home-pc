/// При создании универсальной фукнции, которяа может принимать в себя сразу не сколько видов типов данных, не обязательно создавать union тип параметров

function someType<T>(data: T): T {
  return data;
}

let res1 = someType(2);
let res2 = someType('2');

///Данная заглушка работает след образом: generic <T> получает тип данных в момент получания аршумента и передает его функции в момент срабатывания. В TS это называется обобщением
/// Так же есть способ для обобщения внутри функции

const res3 = someType<number>(12);

///Прием обомщения работате так же и в interface

interface Print<T> {
  design: T;
}
///вместо заглушки Т можно будет аннотировать что угодно в моент использования
const somePrint: Print<string> = {
  design: 'Конфета',
};

const somePrintToo: Print<number> = {
  design: 12,
};
//Обобщения работают со всеми видами, кроме enum!!!!
