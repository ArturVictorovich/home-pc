/// tsc fileName.ts - создание компилятора для TS
/// tsc --init - создание файла с конфигом из библиотеке ts-node
//при указывании аннотации к массиву через Array, JS сразу под капотом указывает generic <T>, на просто нужно указать в скобках тип данных : Array<number>
const arr: Array<number> = [1, 3, 4];
// запись ниже является тойже записью что и выше
const arr2: number[] = [3, 3, 3];

////////
///Встроенное описание с использованием generic, которое как и readonly может сделать неизменеймым обьект, так еще и типизироват его
const roArr: ReadonlyArray<string> = ['sfssfsf'];
// Функция, которая позволяет нам принимать неизменяемость чего либо, помогает анм для работы с библиотеками которые запрещают мутабильность внутри себя. (Redux)

interface InittialState {
  data: { name: string };
  tag?: string;
}
/// модификатор readonly ограничивает изменения только на внешнем уровне, на вложенные элементы он не распрсостроняется
const action = (state: Readonly<InittialState>) => {
  //данное изменение поврехностное
  state.data = 'new string';
  //изменение содержимого обьекта внутри другого обьекта сработало
  state.data.name = 'dddd';
};
// Сущесвуют особоые дженерики для внутренньго изменения с препиской Deep*

/////Встроенные джинерики Partial (паршиал) - добавляет всем свйосвам обьекта модификатор "?"
const initialState: Partial<InittialState> = {};
// TS не бдует ругаться и разместит подобный обьект

///Встроенный джинерик Required - длеает все свойсва обьекта обязательными

const strictState: Required<InittialState> = {
  data: {
    name: 'ff',
  },
  tag: 'ffff',
};
