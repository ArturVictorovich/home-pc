//Рассмотрим ситуацию, когда мы все же получаем не тот тип который ожидали получить
//В парамтерах мы указали тип второго параметра как юнион-тип, либо GET либо POST
const fetchDAta = (url: string, method: 'GET' | 'POST'): void => {
  console.log(method);
};
//А - решение через оператор as
///Обьект который мы передаем как аргумент несет в себе свойсво со строкой "GET"
//Так как обьект разместили без анотации, TS определил сам что внутри него находятся string
const reqOptions = {
  url: 'https://sumeurl.com',
  method: 'GETвыапыр',
};

///Ожидалось получить литерал "GET" либо "POST", а не строку "GET"
//Используем опретор as, для того что бы указать в агрументе что данная позиция точно является тем что нужно, это и есть Утверждение типов в TS
fetchDAta(reqOptions.url, reqOptions.method as 'GET');

//Данная форма не нарушает логику когда, но есть и мунус. При изменениии свойсва обьекта с "GET" на что либо другое, ошибка не возникнет!
//Данный способ не дает совершать не логичные дейсвея, типа 5 as "GET"

//B - в конце закрытия скоборк обьекта написать } as const -
// это будет означать что все элементы обьекта являются литералами

const reqOptiones = {
  url: 'https://sumeurl.com',
  method: 'GETвыапыр',
} as const;

/////////////////////////////
//Пример работы утверждения типов с рабой DOM
//Внутрние интерфейсы в JS для работы с DOM, котоыре помогают добраться до свойсв dom елемнтов
const box = document.querySelector('.box') as HTMLElement;
const input = document.querySelector('input') as HTMLInputElement;
/// значение с инпута является строкой, если мы хотим превести значение к числовому, можно использовать двойной оператор as
const someNumber: number = input.value as any as number;

console.log(someNumber);
